/******************************************
 * @name çŒ›ç”·ä»“åº“æœ€æ–°çŒ›æ–™
 * @statement ä»…ä¾›å­¦ä¹ äº¤æµï¼Œç¦æ­¢ç”¨äºå•†ä¸šç”¨é€”
 * @author ğ’€ğ’–ğ’‰ğ’†ğ’ğ’ˆ
 * @origin https://mncks.buzz/
 * @update 20230712
 * @version 1.0.0
******************************************

[task_local]
30 21 * * * https://raw.githubusercontent.com/Yuheng0101/X/main/Tasks/mnck.js, tag=çŒ›ç”·ä»“åº“æœ€æ–°çŒ›æ–™

[Script]
cron "30 21 * * *" script-path=https://raw.githubusercontent.com/Yuheng0101/X/main/Tasks/mnck.js, timeout=10, tag=çŒ›ç”·ä»“åº“æœ€æ–°çŒ›æ–™

******************************************/
const scriptName = 'çŒ›ç”·ä»“åº“æœ€æ–°çŒ›æ–™'
    , $ = new Env(scriptName)
    , request = $.http
    , baseURL = 'https://mncks.buzz'
    , hitokoto = async () => (await request.get('https://v1.hitokoto.cn/?c=a&encode=text')).body
!(async () => {
    const obj = await getLatestList()
    !obj && $.done()
    const { title, href, thumb } = obj
    $.log('===========================', 'ğŸ””', title, href, thumb, '')
    const lineList = await getLines(href)
    !lineList && $.done()
    const lineObj = lineList[0], { title: lineTitle, href: lineHref } = lineObj
    $.log('===========================', 'ğŸ””', lineTitle, lineHref, '')
    const playURL = await getM3U8(lineHref)
    !playURL && $.done()
    $.log('===========================', 'ğŸ””', playURL, '===========================')
    const yuheng = await hitokoto()
    await $.notify(yuheng, 'ğŸ˜¼å°æ’¸æ€¡æƒ…ğŸ˜‰å¤§æ’¸ä¼¤è‚¾ğŸ˜é€‚æ’¸ç²¾ç¥ç™¾å€', title, { 'media-url': thumb, 'open-url': playURL })
})()
    .catch((e) => $.log('', 'âŒé”™è¯¯ï¼ŒåŸå› ï¼š', e, ''))
    .finally(() => $.done())

async function getLatestList() {
    try {
        const url = `${baseURL}/`
            , { body } = await request.get(url)
            // u can choose it...
            , list = body.match(/<div class=\'block\'>[\s\S]*?<\/div>/g)
            , item = list[Math.floor(Math.random() * list.length)]
            , aTag = item.match(/<a[\s\S]*?<\/a>/g)[0]
            , title = aTag.match(/title=\"(.*?)\"/)[1]
            , href = baseURL + aTag.match(/href=\"(.*?)\"/)[1]
            , imgTag = item.match(/<img[\s\S]*?>/g)[0]
            , thumb = imgTag.match(/src=\"(.*?)\"/)[1]
        return { title, href, thumb }
    } catch (e) {
        $.log('', 'âŒè·å–æœ€æ–°è§†é¢‘é”™è¯¯ï¼š', e, '')
        return null
    }
}
async function getLines(url) {
    try {
        const { body } = await request.get(url)
            , lines = body.match(/<DIV class=play-list>[\s\S]*?<\/DIV>/g)[0].toLocaleLowerCase()
            , aTag = lines.match(/<a[\s\S]*?<\/a>/g)
            , list = aTag.map(item => {
                return {
                    title: item.match(/title=\"(.*?)\"/)[1]
                    , href: baseURL + item.match(/href=\"(.*?)\"/)[1]
                }
            })
        return list
    } catch (e) {
        $.log('', 'âŒè·å–æ’­æ”¾çº¿è·¯é”™è¯¯ï¼š', e, '')
        return null
    }
}
async function getM3U8(url) {
    try {
        const { body } = await request.get(url)
            , toPlayFn = body.match(/to_play\('(.*?)'\)/)
        if (toPlayFn) {
            return base64Decode(toPlayFn[1].match(/http\:(.*)\.m3u8/)[1])
        }
        return body.replace(/[\s\S]*?var playUrl = '(.*?)';[\s\S]*/, '$1')
    } catch (e) {
        $.log('', 'âŒè·å–æ’­æ”¾é“¾æ¥é”™è¯¯ï¼š', e, '')
        return null
    }
}
// prettier-ignore
function base64Decode(r) { var t = (r = String(r).replace(/[\t\n\f\r ]/g, "")).length; t % 4 == 0 && (t = (r = r.replace(/==?$/, "")).length), (t % 4 == 1 || /[^+a-zA-Z0-9/]/.test(r)) && error("Invalid character: the string to be decoded is not correctly encoded."); for (var e, a, c = 0, n = "", o = -1; ++o < t;)a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(r.charAt(o)), e = c % 4 ? 64 * e + a : a, c++ % 4 && (n += String.fromCharCode(255 & e >> (-2 * c & 6))); return n };
// prettier-ignore
function Env(name, opts) { class Http { constructor(env) { this.env = env } send(opts, method = "GET") { opts = "string" == typeof opts ? { url: opts } : opts; let sender = this.get; return "POST" === method && (sender = this.post), new Promise((resolve, reject) => { sender.call(this, opts, (err, resp, body) => { err ? reject(err) : resolve(resp) }) }) } get(opts) { return this.send.call(this.env, opts) } post(opts) { return this.send.call(this.env, opts, "POST") } } return new class { constructor(name, opts) { this.name = name, this.http = new Http(this), this.data = null, this.dataFile = "box.dat", this.logs = [], this.isMute = !1, this.isNeedRewrite = !1, this.logSeparator = "\n", this.encoding = "utf-8", this.startTime = (new Date).getTime(), Object.assign(this, opts), this.log("", `ğŸ””${this.name}, å¼€å§‹!`) } getEnv() { return "undefined" != typeof $environment && $environment["surge-version"] ? "Surge" : "undefined" != typeof $environment && $environment["stash-version"] ? "Stash" : "undefined" != typeof module && module.exports ? "Node.js" : "undefined" != typeof $task ? "Quantumult X" : "undefined" != typeof $loon ? "Loon" : "undefined" != typeof $rocket ? "Shadowrocket" : "undefined" != typeof importModule ? "Scriptable" : "function" == typeof require && "undefined" != typeof $jsbox ? "JSBox" : void 0 } isNode() { return "Node.js" === this.getEnv() } isQuanX() { return "Quantumult X" === this.getEnv() } isSurge() { return "Surge" === this.getEnv() } isLoon() { return "Loon" === this.getEnv() } isShadowrocket() { return "Shadowrocket" === this.getEnv() } isStash() { return "Stash" === this.getEnv() } isScriptable() { return "Scriptable" === this.getEnv() } isJSBox() { return "JSBox" === this.getEnv() } toObj(str, defaultValue = null) { try { return JSON.parse(str) } catch { return defaultValue } } toStr(obj, defaultValue = null) { try { return JSON.stringify(obj) } catch { return defaultValue } } getjson(key, defaultValue) { let json = defaultValue; const val = this.getdata(key); if (val) try { json = JSON.parse(this.getdata(key)) } catch { } return json } setjson(val, key) { try { return this.setdata(JSON.stringify(val), key) } catch { return !1 } } getScript(url) { return new Promise(resolve => { this.get({ url: url }, (err, resp, body) => resolve(body)) }) } runScript(script, runOpts) { return new Promise(resolve => { let httpapi = this.getdata("@chavy_boxjs_userCfgs.httpapi"); httpapi = httpapi ? httpapi.replace(/\n/g, "").trim() : httpapi; let httpapi_timeout = this.getdata("@chavy_boxjs_userCfgs.httpapi_timeout"); httpapi_timeout = httpapi_timeout ? 1 * httpapi_timeout : 20, httpapi_timeout = runOpts && runOpts.timeout ? runOpts.timeout : httpapi_timeout; const [key, addr] = httpapi.split("@"), opts = { url: `http://${addr}/v1/scripting/evaluate`, body: { script_text: script, mock_type: "cron", timeout: httpapi_timeout }, headers: { "X-Key": key, Accept: "*/*" }, timeout: httpapi_timeout }; this.post(opts, (err, resp, body) => resolve(body)) }).catch(e => this.logErr(e)) } loaddata() { if (!this.isNode()) return {}; { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const curDirDataFilePath = this.path.resolve(this.dataFile), rootDirDataFilePath = this.path.resolve(process.cwd(), this.dataFile), isCurDirDataFile = this.fs.existsSync(curDirDataFilePath), isRootDirDataFile = !isCurDirDataFile && this.fs.existsSync(rootDirDataFilePath); if (!isCurDirDataFile && !isRootDirDataFile) return {}; { const datPath = isCurDirDataFile ? curDirDataFilePath : rootDirDataFilePath; try { return JSON.parse(this.fs.readFileSync(datPath)) } catch (e) { return {} } } } } writedata() { if (this.isNode()) { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const curDirDataFilePath = this.path.resolve(this.dataFile), rootDirDataFilePath = this.path.resolve(process.cwd(), this.dataFile), isCurDirDataFile = this.fs.existsSync(curDirDataFilePath), isRootDirDataFile = !isCurDirDataFile && this.fs.existsSync(rootDirDataFilePath), jsondata = JSON.stringify(this.data); isCurDirDataFile ? this.fs.writeFileSync(curDirDataFilePath, jsondata) : isRootDirDataFile ? this.fs.writeFileSync(rootDirDataFilePath, jsondata) : this.fs.writeFileSync(curDirDataFilePath, jsondata) } } lodash_get(source, path, defaultValue) { const paths = path.replace(/\[(\d+)\]/g, ".$1").split("."); let result = source; for (const p of paths) if (result = Object(result)[p], void 0 === result) return defaultValue; return result } lodash_set(obj, path, value) { return Object(obj) !== obj ? obj : (Array.isArray(path) || (path = path.toString().match(/[^.[\]]+/g) || []), path.slice(0, -1).reduce((a, c, i) => Object(a[c]) === a[c] ? a[c] : a[c] = Math.abs(path[i + 1]) >> 0 == +path[i + 1] ? [] : {}, obj)[path[path.length - 1]] = value, obj) } getdata(key) { let val = this.getval(key); if (/^@/.test(key)) { const [, objkey, paths] = /^@(.*?)\.(.*?)$/.exec(key), objval = objkey ? this.getval(objkey) : ""; if (objval) try { const objedval = JSON.parse(objval); val = objedval ? this.lodash_get(objedval, paths, "") : val } catch (e) { val = "" } } return val } setdata(val, key) { let issuc = !1; if (/^@/.test(key)) { const [, objkey, paths] = /^@(.*?)\.(.*?)$/.exec(key), objdat = this.getval(objkey), objval = objkey ? "null" === objdat ? null : objdat || "{}" : "{}"; try { const objedval = JSON.parse(objval); this.lodash_set(objedval, paths, val), issuc = this.setval(JSON.stringify(objedval), objkey) } catch (e) { const objedval = {}; this.lodash_set(objedval, paths, val), issuc = this.setval(JSON.stringify(objedval), objkey) } } else issuc = this.setval(val, key); return issuc } getval(key) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": return $persistentStore.read(key); case "Quantumult X": return $prefs.valueForKey(key); case "Node.js": return this.data = this.loaddata(), this.data[key]; default: return this.data && this.data[key] || null } } setval(val, key) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": return $persistentStore.write(val, key); case "Quantumult X": return $prefs.setValueForKey(val, key); case "Node.js": return this.data = this.loaddata(), this.data[key] = val, this.writedata(), !0; default: return this.data && this.data[key] || null } } initGotEnv(opts) { this.got = this.got ? this.got : require("got"), this.cktough = this.cktough ? this.cktough : require("tough-cookie"), this.ckjar = this.ckjar ? this.ckjar : new this.cktough.CookieJar, opts && (opts.headers = opts.headers ? opts.headers : {}, void 0 === opts.headers.Cookie && void 0 === opts.cookieJar && (opts.cookieJar = this.ckjar)) } get(request, callback = (() => { })) { switch (request.headers && (delete request.headers["Content-Type"], delete request.headers["Content-Length"], delete request.headers["content-type"], delete request.headers["content-length"]), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: this.isSurge() && this.isNeedRewrite && (request.headers = request.headers || {}, Object.assign(request.headers, { "X-Surge-Skip-Scripting": !1 })), $httpClient.get(request, (err, resp, body) => { !err && resp && (resp.body = body, resp.statusCode = resp.status ? resp.status : resp.statusCode, resp.status = resp.statusCode), callback(err, resp, body) }); break; case "Quantumult X": this.isNeedRewrite && (request.opts = request.opts || {}, Object.assign(request.opts, { hints: !1 })), $task.fetch(request).then(resp => { const { statusCode: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes } = resp; callback(null, { status: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes }, body, bodyBytes) }, err => callback(err && err.error || "UndefinedError")); break; case "Node.js": let iconv = require("iconv-lite"); this.initGotEnv(request), this.got(request).on("redirect", (resp, nextOpts) => { try { if (resp.headers["set-cookie"]) { const ck = resp.headers["set-cookie"].map(this.cktough.Cookie.parse).toString(); ck && this.ckjar.setCookieSync(ck, null), nextOpts.cookieJar = this.ckjar } } catch (e) { this.logErr(e) } }).then(resp => { const { statusCode: status, statusCode: statusCode, headers: headers, rawBody: rawBody } = resp, body = iconv.decode(rawBody, this.encoding); callback(null, { status: status, statusCode: statusCode, headers: headers, rawBody: rawBody, body: body }, body) }, err => { const { message: error, response: resp } = err; callback(error, resp, resp && iconv.decode(resp.rawBody, this.encoding)) }) } } post(request, callback = (() => { })) { const method = request.method ? request.method.toLocaleLowerCase() : "post"; switch (request.body && request.headers && !request.headers["Content-Type"] && !request.headers["content-type"] && (request.headers["content-type"] = "application/x-www-form-urlencoded"), request.headers && (delete request.headers["Content-Length"], delete request.headers["content-length"]), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: this.isSurge() && this.isNeedRewrite && (request.headers = request.headers || {}, Object.assign(request.headers, { "X-Surge-Skip-Scripting": !1 })), $httpClient[method](request, (err, resp, body) => { !err && resp && (resp.body = body, resp.statusCode = resp.status ? resp.status : resp.statusCode, resp.status = resp.statusCode), callback(err, resp, body) }); break; case "Quantumult X": request.method = method, this.isNeedRewrite && (request.opts = request.opts || {}, Object.assign(request.opts, { hints: !1 })), $task.fetch(request).then(resp => { const { statusCode: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes } = resp; callback(null, { status: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes }, body, bodyBytes) }, err => callback(err && err.error || "UndefinedError")); break; case "Node.js": let iconv = require("iconv-lite"); this.initGotEnv(request); const { url: url, ..._request } = request; this.got[method](url, _request).then(resp => { const { statusCode: status, statusCode: statusCode, headers: headers, rawBody: rawBody } = resp, body = iconv.decode(rawBody, this.encoding); callback(null, { status: status, statusCode: statusCode, headers: headers, rawBody: rawBody, body: body }, body) }, err => { const { message: error, response: resp } = err; callback(error, resp, resp && iconv.decode(resp.rawBody, this.encoding)) }) } } time(fmt, ts = null) { const date = ts ? new Date(ts) : new Date; let o = { "M+": date.getMonth() + 1, "d+": date.getDate(), "H+": date.getHours(), "m+": date.getMinutes(), "s+": date.getSeconds(), "q+": Math.floor((date.getMonth() + 3) / 3), S: date.getMilliseconds() }; /(y+)/.test(fmt) && (fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length))); for (let k in o) new RegExp("(" + k + ")").test(fmt) && (fmt = fmt.replace(RegExp.$1, 1 == RegExp.$1.length ? o[k] : ("00" + o[k]).substr(("" + o[k]).length))); return fmt } queryStr(options) { let queryString = ""; for (const key in options) { let value = options[key]; null != value && "" !== value && ("object" == typeof value && (value = JSON.stringify(value)), queryString += `${key}=${value}&`) } return queryString = queryString.substring(0, queryString.length - 1), queryString } msg(title = name, subt = "", desc = "", opts) { const toEnvOpts = rawopts => { switch (typeof rawopts) { case void 0: return rawopts; case "string": switch (this.getEnv()) { case "Surge": case "Stash": default: return { url: rawopts }; case "Loon": case "Shadowrocket": return rawopts; case "Quantumult X": return { "open-url": rawopts }; case "Node.js": return }case "object": switch (this.getEnv()) { case "Surge": case "Stash": case "Shadowrocket": default: { let openUrl; return { url: rawopts.url || rawopts.openUrl || rawopts["open-url"] } } case "Loon": { let openUrl, mediaUrl; return { openUrl: rawopts.openUrl || rawopts.url || rawopts["open-url"], mediaUrl: rawopts.mediaUrl || rawopts["media-url"] } } case "Quantumult X": { let openUrl, mediaUrl, updatePasteboard; return { "open-url": rawopts["open-url"] || rawopts.url || rawopts.openUrl, "media-url": rawopts["media-url"] || rawopts.mediaUrl, "update-pasteboard": rawopts["update-pasteboard"] || rawopts.updatePasteboard } } case "Node.js": return }default: return } }; if (!this.isMute) switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: $notification.post(title, subt, desc, toEnvOpts(opts)); break; case "Quantumult X": $notify(title, subt, desc, toEnvOpts(opts)); break; case "Node.js": }if (!this.isMuteLog) { let logs = ["", "==============ğŸ“£ç³»ç»Ÿé€šçŸ¥ğŸ“£=============="]; logs.push(title), subt && logs.push(subt), desc && logs.push(desc), console.log(logs.join("\n")), this.logs = this.logs.concat(logs) } } notify(title = name, subtitle = "", content = "", options = {}) { const openURL = options["open-url"], mediaURL = options["media-url"]; if (this.isQuanX() && $notify(title, subtitle, content, options), this.isSurge() && $notification.post(title, subtitle, content + `${mediaURL ? "\nå¤šåª’ä½“:" + mediaURL : ""}`, { url: openURL }), this.isLoon()) { let opts = {}; openURL && (opts.openUrl = openURL), mediaURL && (opts.mediaUrl = mediaURL), "{}" === JSON.stringify(opts) ? $notification.post(title, subtitle, content) : $notification.post(title, subtitle, content, opts) } if (this.isJSBox()) { const content_ = content + (openURL ? `\nç‚¹å‡»è·³è½¬: ${openURL}` : "") + (mediaURL ? `\nå¤šåª’ä½“: ${mediaURL}` : ""), push = require("push"); push.schedule({ title: title, body: (subtitle ? subtitle + "\n" : "") + content_ }) } if (!this.isMuteLog) { let logs = ["", "==============ğŸ“£ç³»ç»Ÿé€šçŸ¥ğŸ“£=============="]; logs.push(title), subtitle && logs.push(subtitle), content && logs.push(content + (openURL ? `\nç‚¹å‡»è·³è½¬: ${openURL}` : "") + (mediaURL ? `\nå¤šåª’ä½“: ${mediaURL}` : "")), console.log(logs.join("\n")), this.logs = this.logs.concat(logs) } } log(...logs) { logs.length > 0 && (this.logs = [...this.logs, ...logs]), console.log(logs.join(this.logSeparator)) } logErr(err, msg) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": case "Quantumult X": default: this.log("", `â—ï¸${this.name}, é”™è¯¯!`, err); break; case "Node.js": this.log("", `â—ï¸${this.name}, é”™è¯¯!`, err.stack) } } wait(time) { return new Promise(resolve => setTimeout(resolve, time)) } done(val = {}) { const endTime = (new Date).getTime(), costTime = (endTime - this.startTime) / 1e3; switch (this.log("", `ğŸ””${this.name}, ç»“æŸ! ğŸ•› ${costTime} ç§’`), this.log(), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": case "Quantumult X": default: $done(val); break; case "Node.js": process.exit(1) } } }(name, opts) }